const Cve = require('../../model/cve')
const logger = require('../../middleware/logger')
const errors = require('./error')
const error = new errors.CveControllerError()
const CONSTANTS = require('../../constants')
const options = CONSTANTS.PAGINATOR_OPTIONS

async function getCve (req, res, next) {
  try {
    const id = req.ctx.params.id
    const cveRepo = req.ctx.repositories.getCveRepository()
    const result = await cveRepo.findOneByCveId(id)

    if (!result) {
      return res.status(404).json(error.cveRecordDne())
    }

    return res.status(200).json(result.cve)
  } catch (err) {
    next(err)
  }
}

async function getFilteredCves (req, res, next) {
  try {
    options.page = req.ctx.query.page ? parseInt(req.ctx.query.page) : CONSTANTS.PAGINATOR_PAGE // if 'page' query parameter is not defined, set 'page' to the default page value
    const cveRepo = req.ctx.repositories.getCveRepository()
    const timeModified = {
      timeStamp: [],
      dateOperator: []
    }

    Object.keys(req.ctx.query).forEach(k => {
      const key = k.toLowerCase()

      if (key === 'time_modified.lt') {
        timeModified.dateOperator.push('lt')
        timeModified.timeStamp.push(req.ctx.query['time_modified.lt'])
      } else if (key === 'time_modified.gt') {
        timeModified.dateOperator.push('gt')
        timeModified.timeStamp.push(req.ctx.query['time_modified.gt'])
      }
    })

    const query = {}
    if (timeModified.timeStamp.length > 0) {
      query['time.modified'] = {}

      for (let i = 0; i < timeModified.timeStamp.length; i++) {
        if (timeModified.dateOperator[i] === 'lt') {
          query['time.modified'].$lt = timeModified.timeStamp[i]
        } else {
          query['time.modified'].$gt = timeModified.timeStamp[i]
        }
      }
    }

    const agt = [
      {
        $match: query
      },
      {
        $project: {
          _id: false,
          time: false
        }
      }
    ]

    const pg = await cveRepo.aggregatePaginate(agt, options)
    const payload = { cveRecords: pg.itemsList.map(val => { return val.cve }) }

    if (pg.itemCount >= CONSTANTS.PAGINATOR_OPTIONS.limit) {
      payload.totalCount = pg.itemCount
      payload.itemsPerPage = pg.itemsPerPage
      payload.pageCount = pg.pageCount
      payload.currentPage = pg.currentPage
      payload.prevPage = pg.prevPage
      payload.nextPage = pg.nextPage
    }

    logger.info({ uuid: req.ctx.uuid, message: 'The cve records were sent to the user.' })
    return res.status(200).json(payload)
  } catch (err) {
    next(err)
  }
}

// Creates a new CVE only if it does not exists for the specified CVE ID in the request body. If it exists, it does not update the CVE.
async function submitCve (req, res, next) {
  try {
    const newCve = new Cve({ cve: req.ctx.body })
    const id = req.ctx.params.id
    const cveId = newCve.cve.CVE_data_meta.ID
    const state = newCve.cve.CVE_data_meta.STATE
    const cveRepo = req.ctx.repositories.getCveRepository()
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const orgRepo = req.ctx.repositories.getOrgRepository()
    let returned = false

    // the cve id provided in the body must match the cve id provided in the URL params
    if (id !== cveId) {
      returned = true
      return res.status(400).json(error.cveIdMismatch())
    }

    // check that cve does not have status 'RESERVED'
    if (state === CONSTANTS.CVE_STATES.RESERVED && !returned) {
      returned = true
      return res.status(400).json(error.cveCreateUnsupportedState(CONSTANTS.CVE_STATES.RESERVED))
    }

    // check that cve id exists
    let result = await cveIdRepo.findOneByCveId(id)
    if ((!result || result.state === CONSTANTS.CVE_STATES.AVAILABLE) && !returned) {
      returned = true
      return res.status(403).json(error.cveDne())
    }

    // check that cve record does not exist
    result = await cveRepo.findOneByCveId(id)
    if (!returned && result) {
      returned = true
      return res.status(400).json(error.cveRecordExists())
    }

    // update the cve id in MongoDB
    await cveIdRepo.updateByCveId(cveId, { state: state })

    // create cve record in MongoDB if it doesn't exist
    await cveRepo.updateByCveId(cveId, newCve, { upsert: true })

    const responseMessage = {
      message: cveId + ' record was successfully created.',
      created: newCve.cve
    }

    const payload = {
      action: 'create_cve_record',
      change: cveId + ' record was successfully created.',
      req_UUID: req.ctx.uuid,
      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),
      cve: cveId
    }
    const userRepo = req.ctx.repositories.getUserRepository()
    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
    logger.info(JSON.stringify(payload))
    return res.status(200).json(responseMessage)
  } catch (err) {
    next(err)
  }
}

// Updates a CVE if one exists for the specified CVE ID
async function updateCve (req, res, next) {
  try {
    const cve = req.ctx.body
    const newCve = new Cve({ cve: cve })
    const cveId = req.ctx.params.id
    const cveRepo = req.ctx.repositories.getCveRepository()
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const orgRepo = req.ctx.repositories.getOrgRepository()

    // cve id in body must match id in URL param
    if (cveId !== cve.CVE_data_meta.ID) {
      return res.status(400).json(error.cveIdMismatch())
    }

    // check that cve does not have status 'RESERVED'
    if (newCve.cve.CVE_data_meta.STATE === CONSTANTS.CVE_STATES.RESERVED) {
      return res.status(400).json(error.cveUpdateUnsupportedState(CONSTANTS.CVE_STATES.RESERVED))
    }

    // update the cve id in MongoDB
    let result = await cveIdRepo.updateByCveId(cveId, { state: newCve.cve.CVE_data_meta.STATE })

    // check if cve id was found and updated
    if (result.n === 0) {
      logger.info(cveId + ' does not exist.')
      return res.status(403).json(error.cveDne())
    }

    // update CVE record if it exists
    result = await cveRepo.updateByCveId(cveId, newCve)

    // check if CVE record was found and updated
    if (result.n === 0) {
      logger.info(cveId + ' does not exist.')
      return res.status(403).json(error.cveRecordDne())
    }

    const responseMessage = {
      message: cveId + ' record was successfully updated.',
      updated: newCve.cve
    }

    const payload = {
      action: 'update_cve_record',
      change: cveId + ' record was successfully updated.',
      req_UUID: req.ctx.uuid,
      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),
      cve: cveId
    }

    const userRepo = req.ctx.repositories.getUserRepository()
    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
    logger.info(JSON.stringify(payload))
    return res.status(200).json(responseMessage)
  } catch (err) {
    next(err)
  }
}

module.exports = {
  CVE_GET_SINGLE: getCve,
  CVE_GET_FILTERED: getFilteredCves,
  CVE_SUBMIT: submitCve,
  CVE_UPDATE_SINGLE: updateCve
}
