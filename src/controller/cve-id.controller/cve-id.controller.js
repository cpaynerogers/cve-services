require('dotenv').config()
const CveId = require('../../model/cve-id')
const logger = require('../../middleware/logger')
const CONSTANTS = require('../../constants')
const errors = require('./error')
const error = new errors.CveIdControllerError()
const options = CONSTANTS.PAGINATOR_OPTIONS
options.sort = { owning_cna: 'asc', cve_id: 'asc' }

async function getCveId (req, res, next) {
  try {
    const id = req.ctx.params.id
    const orgShortName = req.ctx.org
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const userRepo = req.ctx.repositories.getUserRepository()

    const result = await cveIdRepo.findOneByCveId(id)
    if (!result || result.state === 'AVAILABLE') { // result.state === 'AVAILABLE' check is dead code
      return res.status(404).json(error.cveIdNotFound(id))
    }

    const orgUUID = await orgRepo.getOrgUUID(orgShortName) // orgShortName is not null
    const isSecretariat = await orgRepo.isSecretariatUUID(orgUUID)

    // the requester is not a user in the organization and is not the secretariat
    if (orgUUID !== result.owning_cna && !isSecretariat) {
      if (result.state === 'RESERVED') {
        const cveId = JSON.parse(JSON.stringify(result)) // clone cve id returned from the db
        delete cveId._id

        logger.info({ uuid: req.ctx.uuid, message: id + ' is ' + result.state + '. A 404 status was sent to the requester.', cveId: cveId })
        return res.status(404).json(error.cveIdNotFound(id))
      }

      const cveId = {
        cve_id: result.cve_id,
        cve_year: result.cve_year,
        state: result.state,
        owning_cna: (await orgRepo.findOneByUUID(result.owning_cna)).short_name
      }

      logger.info({ uuid: req.ctx.uuid, message: id + ' record was sent to the user.', cveId: cveId })
      return res.status(200).json(cveId)
    } else {
      // the requester is a user in the organization or is the secretariat
      const cveId = JSON.parse(JSON.stringify(result)) // clone cve id returned from the db
      cveId.owning_cna = (await orgRepo.findOneByUUID(result.owning_cna)).short_name
      cveId.requested_by.cna = (await orgRepo.findOneByUUID(result.requested_by.cna)).short_name
      cveId.requested_by.user = (await userRepo.findOneByUUID(result.requested_by.user)).username
      delete cveId._id

      if (cveId.__v !== undefined) {
        delete cveId.__v
      }

      logger.info({ uuid: req.ctx.uuid, message: id + ' record was sent to the user.', cveId: cveId })
      return res.status(200).json(cveId)
    }
  } catch (err) {
    next(err)
  }
}

async function getFilteredCveId (req, res, next) {
  try {
    const orgShortName = req.ctx.org
    let state
    let year
    const timeReserved = {
      timeStamp: [],
      dateOperator: []
    }
    const timeModified = {
      timeStamp: [],
      dateOperator: []
    }
    let returned = false
    options.page = req.ctx.query.page ? parseInt(req.ctx.query.page) : CONSTANTS.PAGINATOR_PAGE // if 'page' query parameter is not defined, set 'page' to the default page value
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const isSecretariat = await orgRepo.isSecretariat(orgShortName)

    Object.keys(req.ctx.query).forEach(k => {
      const key = k.toLowerCase()

      if (!returned) {
        if (key === 'state') {
          state = req.ctx.query.state
        } else if (key === 'cve_id_year') {
          year = req.ctx.query.cve_id_year
        } else if (key === 'time_reserved.lt') {
          timeReserved.dateOperator.push('lt')
          timeReserved.timeStamp.push(req.ctx.query['time_reserved.lt'])
        } else if (key === 'time_reserved.gt') {
          timeReserved.dateOperator.push('gt')
          timeReserved.timeStamp.push(req.ctx.query['time_reserved.gt'])
        } else if (key === 'time_modified.lt') {
          timeModified.dateOperator.push('lt')
          timeModified.timeStamp.push(req.ctx.query['time_modified.lt'])
        } else if (key === 'time_modified.gt') {
          timeModified.dateOperator.push('gt')
          timeModified.timeStamp.push(req.ctx.query['time_modified.gt'])
        }
      }
    })

    const query = {
      state: { $ne: 'AVAILABLE' }
    }

    if (!isSecretariat) {
      query.owning_cna = await orgRepo.getOrgUUID(orgShortName)
    }

    if (year) {
      query.cve_year = year
    }

    if (state) {
      if (state === 'AVAILABLE') {
        returned = true
        return res.status(200).json({ cve_ids: [] })
      }

      query.state = state
    }

    if (timeReserved.timeStamp.length > 0 && !returned) {
      query.reserved = {}

      for (let i = 0; i < timeReserved.timeStamp.length; i++) {
        if (timeReserved.dateOperator[i] === 'lt') {
          query.reserved.$lt = timeReserved.timeStamp[i]
        } else {
          query.reserved.$gt = timeReserved.timeStamp[i]
        }
      }
    }

    if (timeModified.timeStamp.length > 0 && !returned) {
      query['time.modified'] = {}

      for (let i = 0; i < timeModified.timeStamp.length; i++) {
        if (timeModified.dateOperator[i] === 'lt') {
          query['time.modified'].$lt = timeModified.timeStamp[i]
        } else {
          query['time.modified'].$gt = timeModified.timeStamp[i]
        }
      }
    }

    if (!returned) {
      const agt = [
        {
          $match: query
        },
        {
          $lookup: {
            from: 'Org',
            localField: 'owning_cna',
            foreignField: 'UUID',
            as: 'ownerCna'
          }
        },
        {
          $unwind: '$ownerCna'
        },
        {
          $project: {
            _id: false,
            cve_id: true,
            cve_year: true,
            state: true,
            owning_cna: '$ownerCna.short_name',
            requested_by: true,
            reserved: true,
            time: true
          }
        },
        {
          $lookup: {
            from: 'User',
            localField: 'requested_by.user',
            foreignField: 'UUID',
            as: 'result'
          }
        },
        {
          $unwind: '$result'
        },
        {
          $project: {
            cve_id: true,
            cve_year: true,
            state: true,
            owning_cna: true,
            'requested_by.cna': true,
            'requested_by.user': '$result.username',
            reserved: true,
            time: true
          }
        },
        {
          $lookup: {
            from: 'Org',
            localField: 'requested_by.cna',
            foreignField: 'UUID',
            as: 'result'
          }
        },
        {
          $unwind: '$result'
        },
        {
          $project: {
            cve_id: true,
            cve_year: true,
            state: true,
            owning_cna: true,
            'requested_by.cna': '$result.short_name',
            'requested_by.user': true,
            reserved: true,
            time: true
          }
        }
      ]

      const pg = await cveIdRepo.aggregatePaginate(agt, options)
      const payload = { cve_ids: pg.itemsList }

      if (pg.itemCount >= CONSTANTS.PAGINATOR_OPTIONS.limit) {
        payload.totalCount = pg.itemCount
        payload.itemsPerPage = pg.itemsPerPage
        payload.pageCount = pg.pageCount
        payload.currentPage = pg.currentPage
        payload.prevPage = pg.prevPage
        payload.nextPage = pg.nextPage
      }

      logger.info({ uuid: req.ctx.uuid, message: 'The CVEs were sent to the user.' })
      return res.status(200).json(payload)
    }
  } catch (err) {
    next(err)
  }
}

async function modifyCveId (req, res, next) {
  try {
    const id = req.ctx.params.id
    let returned = false
    let state
    let newOrgShortName
    let orgUUID
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const userRepo = req.ctx.repositories.getUserRepository()

    if (req.ctx.query.state) {
      state = req.ctx.query.state
    }

    if (req.ctx.query.org) {
      newOrgShortName = req.ctx.query.org
    }

    if (state && !returned) {
      if (state === 'RESERVED') {
        returned = true
        return res.status(400).json(error.invalidReservedState())
      } else if (state !== 'PUBLIC' && state !== 'REJECT') { // dead code
        returned = true
        return res.status(400).json(error.invalidState(state))
      }
    }

    if (newOrgShortName && !returned) {
      orgUUID = await orgRepo.getOrgUUID(newOrgShortName)

      if (!orgUUID) {
        returned = true
        logger.info({ uuid: req.ctx.uuid, message: id + ' could not be reassigned to ' + newOrgShortName + ' in MongoDB because it does not exist.' })
        return res.status(404).json(error.orgDne(newOrgShortName))
      }
    }

    let result = await cveIdRepo.findOneByCveId(id)
    if (!result) {
      returned = true
      return res.status(404).json(error.cveIdNotFound(id))
    }

    const updatedCveId = JSON.parse(JSON.stringify(result)) // clone cve id returned from the db
    delete updatedCveId._id
    delete updatedCveId.time

    if (state && !returned) {
      updatedCveId.state = state
    }

    if (newOrgShortName && !returned) {
      updatedCveId.owning_cna = orgUUID
    }

    if (!returned) {
      result = await cveIdRepo.findOneAndUpdate({ cve_id: id }, updatedCveId, { new: true }) // update cve id
      const cveId = JSON.parse(JSON.stringify(result)) // clone cve id returned from the db
      cveId.owning_cna = (await orgRepo.findOneByUUID(result.owning_cna)).short_name
      cveId.requested_by.cna = (await orgRepo.findOneByUUID(result.requested_by.cna)).short_name
      cveId.requested_by.user = (await userRepo.findOneByUUID(result.requested_by.user)).username
      delete cveId._id

      if (cveId.__v !== undefined) {
        delete cveId.__v
      }

      const responseMessage = {
        message: id + ' was successfully updated.',
        updated: cveId
      }

      const payload = {
        action: 'update_cveid',
        change: id + ' was successfully updated.',
        req_UUID: req.ctx.uuid,
        org_UUID: await orgRepo.getOrgUUID(req.ctx.org),
        cve_id: cveId
      }
      payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
      logger.info(JSON.stringify(payload))
      return res.status(200).json(responseMessage)
    }
  } catch (err) {
    next(err)
  }
}

async function reserveCveId (req, res, next) {
  const requester = req.ctx.user
  const orgShortName = req.ctx.org
  let hasLock = false
  let returned = false
  let batchType
  let amount
  let shortName
  let year
  const orgRepo = req.ctx.repositories.getOrgRepository()

  try {
    Object.keys(req.ctx.query).forEach(k => {
      const key = k.toLowerCase()

      if (key === 'amount') {
        amount = req.ctx.query.amount
      } else if (key === 'batch_type') {
        batchType = req.ctx.query.batch_type
      } else if (key === 'short_name') {
        shortName = req.ctx.query.short_name
      } else if (key === 'cve_year') {
        year = req.ctx.query.cve_year
      }
    })

    const isSecretariat = await orgRepo.isSecretariat(orgShortName)
    if (orgShortName !== shortName && !isSecretariat && !returned) {
      returned = true
      return res.status(403).json(error.orgCannotReserveForOther())
    }

    if (!shortName && !returned) {
      returned = true
      return res.status(400).json(error.noOrgShortName())
    }

    if (!year && !returned) {
      returned = true
      return res.status(400).json(error.noYear())
    }

    if (!amount && !returned) {
      returned = true
      return res.status(400).json(error.noAmount())
    }

    if (amount <= 0 && !returned) {
      returned = true
      return res.status(400).json(error.invalidAmount())
    }

    if (amount > 1 && !batchType && !returned) {
      returned = true
      return res.status(400).json(error.noBatchType())
    }

    let result
    if (!returned) {
      result = await orgRepo.findOneByShortName(shortName)

      if (!result) {
        returned = true
        logger.info({ uuid: req.ctx.uuid, message: shortName + ' organization does not exist.' })
        return res.status(403).json(error.orgDne(shortName))
      }
    }

    let payload
    if (!returned) {
      payload = await getPayload(req, result)

      if (amount > payload.available) {
        returned = true
        return res.status(403).json(error.overIdQuota(payload))
      }
    }

    if (!returned) {
      hasLock = await orgRepo.findOneAndUpdate({ short_name: shortName, inUse: false }, { $set: { inUse: true } }, { new: true }) // set lock for org

      if (!hasLock) {
        returned = true
        return res.status(403).json(error.reservationInProgress())
      }
    }

    if (!returned) {
      if (batchType === undefined) { // priority
        await priorityReservation(year, amount, shortName, orgShortName, requester, payload.available, res, req)
      } else if (batchType === 'sequential') {
        await sequentialReservation(year, amount, shortName, orgShortName, requester, payload.available, false, res, req)
      } else if (batchType === 'non-sequential' || batchType === 'nonsequential') {
        if (amount > CONSTANTS.NONSEQUENTIAL_MAX_AMOUNT) {
          returned = true
          return res.status(403).json(error.overNonSequentialMaxAmount())
        }
        await nonSequentialReservation(year, amount, shortName, orgShortName, requester, payload.available, res, req)
      } else {
        return res.status(400).json(error.invalidBatchType())
      }
    }
  } catch (err) {
    next(err)
  } finally {
    if (shortName && hasLock) {
      await orgRepo.findOneAndUpdate({ short_name: shortName, inUse: true }, { $set: { inUse: false } }, { new: true }) // release lock for org
    }
  }
}

async function priorityReservation (year, amount, shortName, orgShortName, requester, availableIds, res, req) {
  const cveIdRangeRepo = req.ctx.repositories.getCveIdRangeRepository()
  const reqUUID = req.ctx.uuid
  let result = await cveIdRangeRepo.findOne({ cve_year: year })
  let returned = false
  let isFull = false

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info({ uuid: req.ctx.uuid, message: 'CVE IDs for year ' + year + ' cannot be reserved at this time.' })
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(error.cannotReserveForYear(year))
  }

  if (!returned) {
    const endRange = parseInt(result.ranges.priority.end)
    result = await cveIdRangeRepo.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.priority.top_id': { $lt: endRange } }] }, { $inc: { 'ranges.priority.top_id': amount } }, { new: true })

    // priority id block is full, reserve id in sequential block
    if (!result) {
      isFull = true
      logger.info({ uuid: req.ctx.uuid, message: 'Priority id block is full for year ' + year + ', reserving id in sequential block.' })
      await sequentialReservation(year, amount, shortName, orgShortName, requester, availableIds, true, res, req)
    }
  }

  if (!isFull && !returned) {
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const userRepo = req.ctx.repositories.getUserRepository()
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const id = generateSequentialIds(year, result.ranges.priority.top_id, amount)
    const owningOrgUUID = await orgRepo.getOrgUUID(shortName)
    const orgUUID = await orgRepo.getOrgUUID(orgShortName)
    const requesterUUID = (await userRepo.findOneByUserNameAndOrgUUID(requester, orgUUID)).UUID

    let cveIdDocuments = []
    const cveIdDocumentsUUID = []
    const cveIdUUID = new CveId()
    const cveId = new CveId()

    cveIdUUID.cve_id = cveId.cve_id = id[0]
    cveIdUUID.cve_year = cveId.cve_year = year
    cveIdUUID.state = cveId.state = 'RESERVED'
    cveIdUUID.owning_cna = owningOrgUUID // the org who gets assigned the reserved CVE IDs
    cveId.owning_cna = shortName
    cveIdUUID.reserved = cveId.reserved = Date.now()
    cveIdUUID.requested_by = {
      cna: orgUUID, // the org who requested the CVE IDs
      user: requesterUUID
    }
    cveId.requested_by = {
      cna: orgShortName, // the org who requested the CVE IDs
      user: requester
    }

    cveIdDocumentsUUID.push(cveIdUUID) // list of cve ids with UUIDs
    cveIdDocuments.push(cveId) // list of cve ids with short name and username

    // Create a CveId document (reserve the CVE ID)
    await cveIdRepo.insertMany(cveIdDocumentsUUID) // reserve a cve id
    cveIdDocuments = cleanOutputSequential(cveIdDocuments)
    const payload = {
      action: 'priority-reservation',
      change: 'A priority CVE ID was reserved for \'' + shortName + '\' organization on behalf of \'' + orgShortName + '\' organization.',
      req_UUID: reqUUID,
      org_UUID: orgUUID,
      user_UUID: requesterUUID,
      amount: amount,
      start: cveIdDocumentsUUID[0].cve_id,
      stop: cveIdDocumentsUUID[cveIdDocumentsUUID.length - 1].cve_id
    }
    logger.info(JSON.stringify(payload))
    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

async function sequentialReservation (year, amount, shortName, orgShortName, requester, availableIds, isPriority, res, req) {
  const cveIdRangeRepo = req.ctx.repositories.getCveIdRangeRepository()
  const reqUUID = req.ctx.uuid
  let result = await cveIdRangeRepo.findOne({ cve_year: year })
  let topId
  let returned = false
  let isFull = false

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info({ uuid: req.ctx.uuid, message: 'CVE IDs for year ' + year + ' cannot be reserved at this time.' })
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(error.cannotReserveForYear(year))
  }

  if (!returned) {
    topId = parseInt(result.ranges.general.top_id)
    amount = parseInt(amount)
    result = await cveIdRangeRepo.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.general.end': { $gt: (topId + amount - 1) } }] }, { $inc: { 'ranges.general.top_id': amount } }, { new: true })
    // The cve id block is full for sequential CVE IDs
    if (!result) {
      isFull = true
      returned = true

      if (isPriority) {
        logger.error(JSON.stringify({ message: 'The cve id priority and sequential blocks are full for year ' + year + '. No more priority or sequential ids can be reserved at this time.' }))
      } else {
        logger.error(JSON.stringify({ message: 'The cve id sequential block is full for year ' + year + '. No more sequential ids can be reserved at this time.' }))
      }

      res.header(CONSTANTS.QUOTA_HEADER, availableIds)
      return res.status(403).json(error.yearRangeFull(year))
    }
  }

  if (!isFull && !returned) {
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const userRepo = req.ctx.repositories.getUserRepository()
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const ids = generateSequentialIds(year, result.ranges.general.top_id, amount)
    const owningOrgUUID = await orgRepo.getOrgUUID(shortName)
    const orgUUID = await orgRepo.getOrgUUID(orgShortName)
    const requesterUUID = (await userRepo.findOneByUserNameAndOrgUUID(requester, orgUUID)).UUID
    let cveIdDocuments = []
    const cveIdDocumentsUUID = []
    let cveIdUUID
    let cveId

    ids.forEach(id => {
      cveIdUUID = new CveId()
      cveId = new CveId()
      cveIdUUID.cve_id = cveId.cve_id = id
      cveIdUUID.cve_year = cveId.cve_year = year
      cveIdUUID.state = cveId.state = 'RESERVED'
      cveIdUUID.owning_cna = owningOrgUUID // the org who gets assigned the reserved CVE IDs
      cveId.owning_cna = shortName
      cveIdUUID.reserved = cveId.reserved = Date.now()
      cveIdUUID.requested_by = {
        cna: orgUUID, // the org who requested the CVE IDs
        user: requesterUUID
      }
      cveId.requested_by = {
        cna: orgShortName, // the org who requested the CVE IDs
        user: requester
      }

      cveIdDocumentsUUID.push(cveIdUUID) // list of cve ids with UUIDs
      cveIdDocuments.push(cveId) // list of cve ids with short name and username
    })

    // Create multiple CveId documents (reserve the CVE IDs)
    await cveIdRepo.insertMany(cveIdDocumentsUUID) // reserve cve ids
    cveIdDocuments = cleanOutputSequential(cveIdDocuments)
    const payload = {
      action: 'sequential-reservation',
      req_UUID: reqUUID,
      org_UUID: orgUUID,
      user_UUID: requesterUUID,
      amount: amount,
      start: cveIdDocumentsUUID[0].cve_id,
      stop: cveIdDocumentsUUID[cveIdDocumentsUUID.length - 1].cve_id
    }

    if (isPriority) {
      payload.change = 'The cve id priority block is full for year ' + year + '. A sequential CVE ID was reserved for \'' + shortName + '\' organization on behalf of \'' + orgShortName + '\' organization.'
    } else {
      payload.change = 'Sequential CVE IDs were reserved for \'' + shortName + '\' organization on behalf of \'' + orgShortName + '\' organization.'
    }

    logger.info(JSON.stringify(payload))
    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

async function nonSequentialReservation (year, amount, shortName, orgShortName, requester, availableIds, res, req) {
  const cveIdRepo = req.ctx.repositories.getCveIdRepository()
  const cveIdRangeRepo = req.ctx.repositories.getCveIdRangeRepository()
  const reqUUID = req.ctx.uuid
  let isFull = false
  let returned = false
  let available
  amount = parseInt(amount)
  let availableLimit = Math.max(3 * amount, CONSTANTS.DEFAULT_AVAILABLE_POOL)
  let result = await cveIdRangeRepo.findOne({ cve_year: year })

  // Cve Id Range for 'year' does not exists
  if (!result) {
    returned = true
    logger.info({ uuid: req.ctx.uuid, message: 'CVE IDs for year ' + year + ' cannot be reserved at this time.' })
    res.header(CONSTANTS.QUOTA_HEADER, availableIds)
    return res.status(403).json(error.cannotReserveForYear(year))
  }

  if (!returned) {
    available = await cveIdRepo.find({ cve_year: year, state: 'AVAILABLE' }, { limit: availableLimit }) // get available ids

    // Case 1: Not enough IDs in the 'AVAILABLE' pool
    if (available.length < availableLimit) {
      result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount, available.length, year, cveIdRangeRepo)
      isFull = result.isFull
      returned = result.returned

      if (isFull || returned) {
        logger.error(JSON.stringify({ message: 'The cve id non-sequential block is full for year ' + year + '. No more sequential ids can be reserved at this time.' }))
        res.header(CONSTANTS.QUOTA_HEADER, availableIds)
        return res.status(403).json(error.yearRangeFull(year))
      }

      await allocateAvailableCveIds(result.ids, year, req) // Pool was incremented. Create 'AVAILABLE' cve ids.
      available = await cveIdRepo.find({ cve_year: year, state: 'AVAILABLE' }, { limit: availableLimit }) // get available ids
    }
  }

  // Case 2: Enough IDs in the 'AVAILABLE' pool
  const orgRepo = req.ctx.repositories.getOrgRepository()
  const userRepo = req.ctx.repositories.getUserRepository()
  let index
  let counter = 0
  const cveIdDocuments = []
  const cveIdDocumentsUUID = []
  const owningOrgUUID = await orgRepo.getOrgUUID(shortName)
  const orgUUID = await orgRepo.getOrgUUID(orgShortName)
  const requesterUUID = (await userRepo.findOneByUserNameAndOrgUUID(requester, orgUUID)).UUID

  while ((counter < amount) && (!isFull && !returned)) {
    index = getRandomInt(0, available.length) // get random index in the available array
    result = await reserveNonSequentialCveId(index, available, year, shortName, orgShortName, requester, owningOrgUUID, orgUUID, requesterUUID, cveIdRepo)

    if (result.isReserved) {
      logger.info({ uuid: req.ctx.uuid, message: result.cveId.cve_id + ' was reserved' })
      cveIdDocuments.push(result.cveId) // add reserved cve id to the array of reserved cve ids
      cveIdDocumentsUUID.push(result.cveIdUUID) // add reserved cve id UUID to the array of reserved cve ids
      available.splice(index, 1) // remove reserved cve id from the 'AVAILABLE' pool
      counter++
    } else {
      available = await cveIdRepo.find({ cve_year: year, state: 'AVAILABLE' }, { limit: availableLimit }) // get available ids
      availableLimit = Math.max(3 * (amount - counter), CONSTANTS.DEFAULT_AVAILABLE_POOL) // recalculate the available limit since some ids might have been reserved

      // Case 1: Not enough IDs in the 'AVAILABLE' pool
      if (available.length < availableLimit) {
        result = await cveIdRangeRepo.findOne({ cve_year: year })
        result = await incrementNonSequentialPool(availableLimit, result.ranges.general.end, result.ranges.general.top_id, amount - counter, available.length, year, cveIdRangeRepo)
        isFull = result.isFull
        returned = result.returned

        if (isFull || returned) {
          logger.info({ uuid: req.ctx.uuid, message: 'Only ' + counter + ' cve ids were reserved because there are not enough ids in the CVE ID non-sequential block. Non-sequential CVE IDs were reserved for \'' + shortName + '\' organization on behalf of \'' + orgShortName + '\' organization.', cve_ids: cveIdDocumentsUUID.map((doc) => { return doc.cve_id }) })
          res.header(CONSTANTS.QUOTA_HEADER, availableIds - counter)
          return res.status(206).json(error.reservedPartialAmount(counter, cveIdDocuments))
        }

        await allocateAvailableCveIds(result.ids, year, req) // Pool was incremented. Create 'AVAILABLE' cve ids.
        available = await cveIdRepo.find({ cve_year: year, state: 'AVAILABLE' }, { limit: availableLimit }) // get available ids
      }
    }
  }

  const reservedCveIds = cveIdDocumentsUUID.map((doc) => {
    return doc.cve_id
  })

  if (!isFull && !returned) {
    const payload = {
      action: 'nonsequential-reservation',
      change: 'Non-sequential CVE IDs were reserved for \'' + shortName + '\' organization on behalf of \'' + orgShortName + '\' organization.',
      req_UUID: reqUUID,
      org_UUID: orgUUID,
      user_UUID: requesterUUID,
      amount: amount,
      cve_ids: reservedCveIds
    }

    logger.info(JSON.stringify(payload))
    res.header(CONSTANTS.QUOTA_HEADER, availableIds - amount)
    return res.status(200).json({ cve_ids: cveIdDocuments })
  }
}

async function incrementNonSequentialPool (availableLimit, end, top, amount, available, year, cveIdRR) {
  let increment = availableLimit - available + amount // the amount is the increment amount
  const cveIdRangeRepo = cveIdRR
  const endRange = parseInt(end)
  const topId = parseInt(top)

  // Cap increment to end of general CVE ID block
  if (endRange < (topId + increment)) {
    increment = endRange - topId
  }

  const result = {
    isFull: false,
    returned: false,
    ids: null
  }

  if (increment > 0) {
    let r = await cveIdRangeRepo.findOneAndUpdate({ $and: [{ cve_year: year }, { 'ranges.general.end': { $gte: increment } }] }, { $inc: { 'ranges.general.top_id': increment } }, { new: true })

    // Cap increment because it went over end of general block
    if (r.ranges.general.top_id > endRange) {
      increment = increment - (r.ranges.general.top_id - endRange) // adjusting real increment
      r = await cveIdRangeRepo.findOneAndUpdate({ cve_year: year }, { $set: { 'ranges.general.top_id': endRange } }, { new: true }) // Cap top_id to end of the block
    }

    if (increment > 0) {
      result.ids = generateSequentialIds(year, r.ranges.general.top_id, increment)
    } else if (available < amount) { // You hit the end of the boundary
      result.isFull = true
      result.returned = true
    }
  } else if (available < amount) { // You hit the end of the boundary
    result.isFull = true
    result.returned = true
  }

  return result
}

async function allocateAvailableCveIds (ids, year, req) {
  if (ids) {
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    const cveIdDocuments = []
    let cveId

    ids.forEach(id => {
      cveId = new CveId()
      cveId.cve_id = id
      cveId.cve_year = year
      cveId.state = 'AVAILABLE'
      cveId.owning_cna = 'N/A' // the org who gets assigned the reserved CVE IDs
      cveId.reserved = Date.now()
      cveId.requested_by = {
        cna: 'N/A', // the org who requested the CVE IDs
        user: 'N/A'
      }

      cveIdDocuments.push(cveId)
    })

    await cveIdRepo.insertMany(cveIdDocuments) // Save the 'AVAILABLE' cve ids
    logger.info({ uuid: req.ctx.uuid, message: 'The AVAILABLE pool was incremented by ' + cveIdDocuments.length + ' cve ids.' })
  }
}

async function reserveNonSequentialCveId (index, available, year, shortName, orgShortName, requester, owningOrgUUID, orgUUID, requesterUUID, cveIdR) {
  // Update available Cve Id
  const cveIdUUID = new CveId()
  const cveId = new CveId()
  const cveIdRepo = cveIdR
  cveIdUUID.cve_id = cveId.cve_id = available[index].cve_id
  cveIdUUID.cve_year = cveId.cve_year = year
  cveIdUUID.state = cveId.state = 'RESERVED'
  cveIdUUID.owning_cna = owningOrgUUID
  cveId.owning_cna = shortName // the org who gets assigned the reserved CVE IDs
  cveIdUUID.reserved = cveId.reserved = Date.now()
  cveIdUUID.requested_by = {
    cna: orgUUID, // the org who requested the CVE IDs
    user: requesterUUID
  }
  cveId.requested_by = {
    cna: orgShortName, // the org who requested the CVE IDs
    user: requester
  }

  const result = {
    cveId: cveId,
    cveIdUUID: cveIdUUID,
    isReserved: await cveIdRepo.findOneAndUpdate({ cve_id: cveIdUUID.cve_id, state: 'AVAILABLE' }, cveIdUUID, { new: true })
  }

  return result
}

async function getPayload (req, org) {
  const payload = {
    id_quota: org.policies.id_quota
  }
  const cveIdRepo = req.ctx.repositories.getCveIdRepository()

  const result = await cveIdRepo.countDocuments({ owning_cna: org.UUID, state: 'RESERVED' })
  payload.total_reserved = result
  payload.available = (payload.id_quota - payload.total_reserved)

  return payload
}

function cleanOutputSequential (cveIdDocuments) {
  cveIdDocuments.forEach((obj) => {
    const cveId = JSON.parse(JSON.stringify(obj))
    delete cveId.time

    if (cveId.__v !== undefined) {
      delete cveId.__v
    }
  })

  return cveIdDocuments
}

function generateSequentialIds (year, topId, amount) {
  const start = topId - amount + 1 // before the pool 'AVAILABLE' pool increment
  const end = topId // after the 'AVAILABLE' pool increment
  const ids = []

  for (let i = start; i < end + 1; i++) {
    ids.push('CVE-' + year + '-' + String(i).padStart(4, '0'))
  }

  return ids
}

function getRandomInt (min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)

  return Math.floor(Math.random() * (max - min) + min) // The maximum is exclusive and the minimum is inclusive
}

async function createCveIdRange (req, res, next) {
  try {
    const year = req.ctx.params.year
    const cveIdRangeRepo = req.ctx.repositories.getCveIdRangeRepository()
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const userRepo = req.ctx.repositories.getUserRepository()
    const result = await cveIdRangeRepo.findOne({ cve_year: year })

    if (result) {
      logger.info({ uuid: req.ctx.uuid, message: 'CVE Id Range document for year ' + year + ' already exists.' })
      return res.status(400).json(error.yearRangeExists(year))
    }

    const defaultDoc = CONSTANTS.DEFAULT_CVE_ID_RANGE
    defaultDoc.cve_year = year
    await cveIdRangeRepo.findOneAndUpdate({ cve_year: year }, defaultDoc, { upsert: true })
    const payload = {
      action: 'create_cveIdRange',
      change: 'CVE Id Range document for year ' + year + ' was created.',
      req_UUID: req.ctx.uuid,
      org_UUID: await orgRepo.getOrgUUID(req.ctx.org)
    }
    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)

    logger.info(JSON.stringify(payload))
    return res.status(200).send()
  } catch (err) {
    next(err)
  }
}

module.exports = {
  CVEID_GET_SINGLE: getCveId,
  CVEID_RESERVE: reserveCveId,
  CVEID_GET_FILTER: getFilteredCveId,
  CVEID_UPDATE_SINGLE: modifyCveId,
  CVEID_RANGE_CREATE: createCveIdRange
}
