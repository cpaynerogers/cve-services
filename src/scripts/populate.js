/*
 * used to populate or re-populate a MongoDB-compatible document
 * database with static fixtures at `cve-services/datadump/pre-population`
 */

const express = require('express')
const config = require('config')
const mongoose = require('mongoose')
const uuid = require('uuid')
const app = express()
const logger = require('../middleware/logger')
const CveIdRange = require('../model/cve-id-range')
const CveId = require('../model/cve-id')
const Cve = require('../model/cve')
const Org = require('../model/org')
const User = require('../model/user')
const argon2 = require('argon2')
const cryptoRandomString = require('crypto-random-string')
const CONSTANTS = require('../constants')
const utils = require('../utils/utils')
const cveIdRangeData = require('../../datadump/pre-population/cve-ids-range')
const cveIdData = require('../../datadump/pre-population/cve-ids')
const cveData = require('../../datadump/pre-population/cves')
const orgData = require('../../datadump/pre-population/orgs')
const userData = require('../../datadump/pre-population/users')
const ProgressBar = require('progress')
const fs = require('fs')
const errors = require('../utils/error')
const error = new errors.IDRError()
const apiKeyFile = 'user-secret.txt'
require('dotenv').config() // This enables us to read from the .env file.

// Body Parser Middleware
app.use(express.json()) // Allows us to handle raw JSON data
app.use(express.urlencoded({ extended: false })) // Allows us to handle url encoded data
// Make mongoose connection available globally
global.mongoose = mongoose

// construct MongoDB connection string
// assumes that host, port, database are always defined in default config, but
// that username and password may not be
const appEnv = process.env.NODE_ENV
let dbUser, dbPassword

if (process.env.MONGO_USER && process.env.MONGO_PASSWORD) {
  dbUser = process.env.MONGO_USER
  dbPassword = process.env.MONGO_PASSWORD
} else {
  dbUser = config.has(`${appEnv}.username`) ? config.get(`${appEnv}.username`) : false
  dbPassword = config.has(`${appEnv}.password`) ? config.get(`${appEnv}.password`) : false
}

const dbHost = process.env.MONGO_HOST ? process.env.MONGO_HOST : config.get(`${appEnv}.host`)
const dbPort = process.env.MONGO_PORT ? process.env.MONGO_PORT : config.get(`${appEnv}.port`)
const dbName = config.get(`${appEnv}.database`)
const dbLoginPrepend = (dbUser && dbPassword) ? `${dbUser}:${dbPassword}@` : ''
const dbConnectionStr = `mongodb://${dbLoginPrepend}${dbHost}:${dbPort}/${dbName}`

// Connect to MongoDB database
mongoose.connect(dbConnectionStr, {
  useNewUrlParser: true,
  useUnifiedTopology: false,
  useFindAndModify: false
})

// database connection
const db = mongoose.connection

db.on('error', () => {
  console.error.bind(console, 'Connection Error: Something went wrong!')
  logger.error(error.connectionError())
})

db.once('open', async () => {
  // we're connected!
  logger.info(`Successfully connected to database ${dbName} at ${dbHost}:${dbPort}`)

  // Ask user to confirm pre-population, which will prep MongoDB by removing the Cve-Id, Org, and User collections
  const prompt = require('prompt-sync')({ sigint: true })
  let userInput = prompt(
    `Are you sure you wish to pre-populate the database for the ${appEnv} environment?` +
    "Doing so will drop the 'Cve', 'Cve-Id-Range', 'Cve-Id', 'Org' and 'User' collections" +
    `in the ${dbName} database. (y/n) `
  )

  while (userInput.toLowerCase() !== 'n' && userInput.toLowerCase() !== 'y') {
    console.log('Unrecognized Input')
    userInput = prompt(
      `Do you wish to pre-populate the database for the ${appEnv} environment?` +
      "Doing so will drop the 'Cve', 'Cve-Id-Range', 'Cve-Id', 'Org' and 'User' collections" +
      `in the ${dbName} database. (y/n) `
    )
  }

  // droping Cve-Id, Org, and User collections
  if (userInput.toLowerCase() === 'y') {
    let names = []
    let collections = await db.db.listCollections().toArray()
    collections.forEach(collection => {
      names.push(collection.name)
    })

    if (names.includes('Cve')) {
      await db.dropCollection('Cve')
    }

    if (names.includes('Cve-Id-Range')) {
      await db.dropCollection('Cve-Id-Range')
    }

    if (names.includes('Cve-Id')) {
      await db.dropCollection('Cve-Id')
    }

    if (names.includes('Org')) {
      await db.dropCollection('Org')
    }

    if (names.includes('User')) {
      await db.dropCollection('User')
    }

    names = []
    collections = await db.db.listCollections().toArray()
    collections.forEach(collection => {
      names.push(collection.name)
    })

    if (!names.includes('Cve-Id-Range') && !names.includes('Cve-Id') && !names.includes('Cve') && !names.includes('Org') && !names.includes('User')) {
      // assumes we have all files, since we will in production

      // these are independent (require no UUID linking)
      await populateCveIdRangeCollection()
      await populateOrgCollection()

      // user collection depends on orgs
      await populateUserCollection()

      // cve-id collection depends on users and orgs
      await populateCveIdCollection()

      // cve collection could depend on all existing collections once its updated
      await populateCveCollection()

      logger.info('Successfully pre-populated the database!')
    } else {
      logger.error('The database was not populated because some of the collections were not deleted.')
    }
  }

  // close MongoDB connection
  mongoose.connection.close()
})

async function populateCveIdRangeCollection () {
  const bar = new ProgressBar('Cve-Id-Range collection [:bar] :percent', {
    complete: '=',
    incomplete: ' ',
    width: 20,
    total: cveIdRangeData.length
  })

  let batchCveIdRange = []
  for (let i = 0; i < cveIdRangeData.length; i++) {
    batchCveIdRange.push(cveIdRangeData[i])

    const isLastItem = i === cveIdRangeData.length - 1
    if (i % 1000 === 0 || isLastItem) {
      await CveIdRange.insertMany(batchCveIdRange)
      bar.tick(batchCveIdRange.length)
      batchCveIdRange = []
    }
  }

  logger.info('Cve-Id-Range collection populated')
}

// Populating Org collection
async function populateOrgCollection () {
  const bar = new ProgressBar('Org collection [:bar] :percent', {
    complete: '=',
    incomplete: ' ',
    width: 40,
    total: orgData.length
  })

  let batchOrgData = []
  for (let i = 0; i < orgData.length; i++) {
    const org = orgData[i]
    org.UUID = uuid.v4()
    org.inUse = false
    batchOrgData.push(org)

    const isLastItem = i === orgData.length - 1
    if (i % 1000 === 0 || isLastItem) {
      await Org.insertMany(batchOrgData)
      bar.tick(batchOrgData.length)
      batchOrgData = []
    }
  }

  logger.info('Org collection populated')
}

// Populating User collection
async function populateUserCollection () {
  const color = require('kleur')
  let hash
  let secretKey

  if (process.env.NODE_ENV === 'development') {
    secretKey = process.env.LOCAL_KEY
    hash = await argon2.hash(secretKey)

    // provide secret to user
    console.log(color.bold().black().bgWhite('Use the following API secret for all users:') + ' ' + color.bold().black().italic().bgGreen(secretKey))
  } else {
    // delete file for user secrets if one already exists
    fs.unlink(apiKeyFile, err => {
      if (err && err.code !== 'ENOENT') {
        logger.error(error.fileDeleteError(err))
        // close MongoDB connection
        mongoose.connection.close()
      }
    })

    console.log(color.bold().black().bgWhite('The users\' API secret can be found in:') + ' ' + color.bold().black().italic().bgGreen(apiKeyFile))
  }

  const bar = new ProgressBar('User collection [:bar] :percent', {
    complete: '=',
    incomplete: ' ',
    width: 40,
    total: userData.length
  })

  let batchUser = []
  for (let i = 0; i < userData.length; i++) {
    const user = userData[i]
    batchUser.push(user)

    // no matter the environment, link User to Org by UUID
    const tmpOrgUUID = await utils.getOrgUUID(user.cna_short_name)
    user.org_UUID = tmpOrgUUID
    user.UUID = uuid.v4()
    user.authority = {
      active_roles: []
    }

    if (process.env.NODE_ENV === 'development') {
      user.secret = hash
    } else {
      const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })
      user.secret = await argon2.hash(randomKey)

      const payload = {
        username: user.username,
        secret: randomKey
      }

      // write pair.apiKey to apiKey file
      fs.writeFile(apiKeyFile, JSON.stringify(payload) + '\n', { flag: 'a' }, (err) => {
        if (err) {
          logger.error(error.fileWriteError(err))
          // close MongoDB connection
          mongoose.connection.close()
        }
      })
    }

    const isLastItem = i === userData.length - 1
    if (i % 1000 === 0 || isLastItem) {
      await User.insertMany(batchUser)
      bar.tick(batchUser.length)
      batchUser = []
    }
  }

  logger.info('User collection populated')
}

// Populating Cve-Id collection
async function populateCveIdCollection () {
  const bar = new ProgressBar('Cve-Id collection [:bar] :percent', {
    complete: '=',
    incomplete: ' ',
    width: 40,
    total: cveIdData.length
  })

  // replace Org and User values with their UUID equivalents
  // unlike in the view, we don't care about the original data
  let batchCveIds = []
  for (let i = 0; i < cveIdData.length; i++) {
    const cveid = cveIdData[i]
    batchCveIds.push(cveid)

    // get our three UUIDs: requesting CNA, owning CNA, requesting User
    const tmpRequestingCnaUUID = await utils.getOrgUUID(cveid.requested_by.cna)
    cveid.requested_by.cna = tmpRequestingCnaUUID
    const tmpOwningCnaUUID = await utils.getOrgUUID(cveid.owning_cna)
    cveid.owning_cna = tmpOwningCnaUUID
    const tmpUserUUID = await utils.getUserUUID(cveid.requested_by.user, tmpRequestingCnaUUID)
    cveid.requested_by.user = tmpUserUUID

    const isLastItem = i === cveIdData.length - 1
    if (i % 1000 === 0 || isLastItem) {
      await CveId.insertMany(batchCveIds)
      bar.tick(batchCveIds.length)
      batchCveIds = []
    }
  }

  // success!
  logger.info('Cve-Id collection populated')
}

// Populating Cve collection
async function populateCveCollection () {
  const bar = new ProgressBar('Cve collection [:bar] :percent', {
    complete: '=',
    incomplete: ' ',
    width: 40,
    total: cveData.length
  })

  let batchCves = []
  for (let i = 0; i < cveData.length; i++) {
    const cve = cveData[i]
    batchCves.push(cve)

    const isLastItem = i === cveData.length - 1
    if (i % 1000 === 0 || isLastItem) {
      await Cve.insertMany(batchCves)
      bar.tick(batchCves.length)
      batchCves = []
    }
  }

  // success!
  logger.info('Cve collection populated')
}
