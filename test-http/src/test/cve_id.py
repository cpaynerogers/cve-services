import copy
import datetime as dt
import json
import pytest
import requests
import time
import uuid
from src import env, utils
from src.utils import (assert_contains, ok_response_contains,
                       response_contains, response_contains_json)

CVE_ID_URL = '/api/cve-id'
cve_id = 'CVE-1999-0001'


def test_get_cve_id():
    """ the first ID from 1999 should always exist """
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS
    )
    ok_response_contains(res, cve_id)


def test_get_cve_id_bad_org_header():
    """ unauthorized users can't get known IDs """
    uid = str(uuid.uuid4())
    tmp = copy.deepcopy(utils.BASE_HEADERS)
    tmp['CVE-API-ORG'] = uid
    tmp['CVE-API-USER'] = uid
    res = requests.get(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=tmp
    )
    assert res.status_code == 401
    assert res.reason == 'Unauthorized'
    response_contains_json(res, 'error', 'UNAUTHORIZED')


def test_put_cve_id_id():
    """ an id can be updated to reject or public """
    res = requests.put(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS,
        params={'state':'REJECT'}
    )
    ok_response_contains(res, f'{cve_id} was successfully updated.')

    res = requests.put(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS,
        params={'state':'PUBLIC'}
    )
    ok_response_contains(res, f'{cve_id} was successfully updated.')


def test_put_cve_id_id_state_reserved():
    """ an id's state cannot be set back to reserved """
    res = requests.put(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS,
        params={'state':'REJECT'}
    )
    ok_response_contains(res, f'{cve_id} was successfully updated.')

    res = requests.put(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS,
        params={'state':'RESERVED'}
    )
    assert res.status_code == 400
    response_contains_json(
        res, 'message',
        'Cannot change the state to RESERVED.')


def test_put_cve_id_id_state_blarg():
    """ an id's state can only be set to public or reject """
    res = requests.put(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS,
        params={'state':'BLARG'}
    )
    assert res.status_code == 400
    assert 'BLARG' not in res.content.decode()
    response_contains(res, 'state')
    response_contains_json(res, 'message', 'Parameters were invalid')  


def test_put_cve_id_id_no_params():
    """ cve id endpoint ... accepts an empty query set? """
    res = requests.put(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS
    )
    # NOTE: should this behave as if an update was successful, when no params
    # were included and nothing was actually updated?
    ok_response_contains(res, f'{cve_id} was successfully updated.')


def test_put_cve_id_id_empty_params():
    """ cve services id update endpoint fails for empty query parameters """
    res = requests.put(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}',
        headers=utils.BASE_HEADERS,
        params={'state': '', 'cna': ''}
    )
    assert res.status_code == 400
    response_contains(res, 'state')
    response_contains_json(res, 'message', 'Parameters were invalid') 


def test_post_cve_id_no_params():
    """ batch type is the only optional parameter for reserving ids """
    res = requests.post(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}',
        headers=utils.BASE_HEADERS
    )
    assert res.status_code == 400
    response_contains(res, 'amount')
    response_contains(res, 'cve_year')
    response_contains(res, 'short_name')


def test_post_cve_id_empty_params():
    """ cve services doesn't accept id reservation with blank parameters """
    res = requests.post(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}',
        headers=utils.BASE_HEADERS,
        params={
            'amount': '',
            'batch_type': '',
            'cve_year': '',
            'short_name': ''
        }
    )
    # NOTE: there isn't a `short_name` error here, why?
    assert res.status_code == 400
    response_contains(res, 'amount')
    response_contains(res, 'cve_year')


def test_post_cve_id_empty_short_name():
    """ cve services rejects empty short name separately """
    res = requests.post(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}',
        headers=utils.BASE_HEADERS,
        params={
            'amount': '10',
            'batch_type': 'sequential',
            'cve_year': f'{utils.CURRENT_YEAR}',
            'short_name': ''
        }
    )
    assert res.status_code == 400
    response_contains_json(res, 'error', 'NO_ORG_SHORTNAME')


def test_post_cve_id_bad_amount():
    """ api rejects non-numeric amount when requesting IDs """
    res = get_reserve_cve_ids('a', utils.CURRENT_YEAR, 'mitre')
    assert res.status_code == 400
    assert res.reason == 'Bad Request'
    response_contains_json(res, 'error', 'BAD_INPUT')
    assert_contains(res, 'amount')


def test_put_cve_id_duplicate_state():
    """ api rejects ID updates with duplicate state parameter """
    res = requests.put(
        (f'{env.AWG_BASE_URL}{CVE_ID_URL}/{cve_id}'
          '?state=RESERVED&state=PUBLIC'),
        headers=utils.BASE_HEADERS
    )
    assert res.status_code == 400
    assert res.reason == 'Bad Request'
    response_contains_json(res, 'error', 'BAD_INPUT')
    assert_contains(res, 'state')


def test_post_cve_id_reserve_priority():
    """ priority ids can be reserved on behalf of the mitre org """
    res = requests.post(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}',
        headers=utils.BASE_HEADERS,
        params={
            'amount': '1',
            'cve_year': f'{utils.CURRENT_YEAR}',
            'short_name': 'mitre'
        }
    )
    ok_response_contains(res, f'CVE-{utils.CURRENT_YEAR}-')
    assert json.loads(res.content.decode())['cve_ids']
    assert len(json.loads(res.content.decode())['cve_ids']) == 1
    
    priority_id = json.loads(res.content.decode())['cve_ids'][0]['cve_id']
    assert int(priority_id.split('-')[-1]) < 20000


# Does this constitute a performance test? The distinction I'm making is that
# performance tests stress the system overall, while these tests try to
# test both "reservation works" and "there's some reasonable amount that we
# can request that doesn't stress the system"
@pytest.mark.parametrize(
    "batch_type, amount",
    [('sequential', 10), ('sequential', 1000),
     ('nonsequential', 1), ('nonsequential', 10)])
def test_post_cve_id_reservation(batch_type, amount):
    """ sequential ids can be reserved on behalf of the mitre org """
    res = get_reserve_cve_ids(amount, utils.CURRENT_YEAR, 'mitre', batch_type)
    ok_response_contains(res, f'CVE-{utils.CURRENT_YEAR}-')
    assert json.loads(res.content.decode())['cve_ids']
    assert len(json.loads(res.content.decode())['cve_ids']) == amount


def test_post_cve_id_reserve_sequential_over_quota():
    """ the services api enforces a max quota of 100,000 """
    res = get_reserve_cve_ids(100001, utils.CURRENT_YEAR, 'mitre')
    assert res.status_code == 403
    response_contains_json(res, 'error', 'EXCEEDED_ID_QUOTA')


def test_post_cve_id_reserve_nonsequential_over_limit():
    """ the services api enforces a max non-sequential limit of 10 """
    res = get_reserve_cve_ids(11, utils.CURRENT_YEAR, 'mitre', 'nonsequential')
    assert res.status_code == 403
    response_contains_json(res, 'error', 'OVER_NONSEQUENTIAL_MAX_AMOUNT')


def test_get_cve_id_by_time_reserved():
    """ we can get ids immediately after reserving them using the time they're
    reserved (noting that this may not work against a shared integration
    environment, we check that at least this many have been reserved) """
    n_ids = 10
    time.sleep(1)
    t_before = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
    time.sleep(1)
    res_ids = get_reserve_cve_ids(n_ids, utils.CURRENT_YEAR, 'mitre')
    time.sleep(1)
    t_after = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    res_get_ids = requests.get(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}',
        headers=utils.BASE_HEADERS,
        params={
            'time_reserved.lt': t_after,
            'time_reserved.gt': t_before
        }
    )
    ok_response_contains(res_get_ids, f'CVE-{utils.CURRENT_YEAR}-')
    assert len(json.loads(res_get_ids.content.decode())['cve_ids']) == n_ids


def test_get_cve_id_by_time_modified():
    """ we can get ids immediately after reserving them using the time they're
    reserved (noting that this may not work against a shared integration
    environment, we check that at least this many have been reserved) """
    n_ids = 10
    time.sleep(1)
    t_before = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
    time.sleep(1)
    res_ids = get_reserve_cve_ids(n_ids, utils.CURRENT_YEAR, 'mitre')
    time.sleep(1)
    t_after = dt.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    res_get_ids = requests.get(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}',
        headers=utils.BASE_HEADERS,
        params={
            'time_modified.lt': t_after,
            'time_modified.gt': t_before
        }
    )
    ok_response_contains(res_get_ids, f'CVE-{utils.CURRENT_YEAR}-')
    assert len(json.loads(res_get_ids.content.decode())['cve_ids']) == n_ids



# CVE-ID ENDPOINT UTILITIES
# ==============================================================================
# these are unique to the `{CVE_ID_URL}` endpoint for the AWG system


def get_reserve_cve_ids(
        amount, year, cna_short_name, batch_type='sequential'):
    return requests.post(
        f'{env.AWG_BASE_URL}{CVE_ID_URL}',
        headers=utils.BASE_HEADERS,
        params={
            'amount': f'{amount}',
            'batch_type': batch_type,
            'cve_year': f'{year}',
            'short_name': cna_short_name
        }
    )
